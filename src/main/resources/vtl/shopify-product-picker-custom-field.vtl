#[[

<!-- shopify-product-picker.js -->
<script type="module">
    class ShopifyProductPicker extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: "open" });
            this.selectedProductKey = "selectedShopifyProduct";
            this.state = {
                selected: null,
                search: "",
                results: [],
                searching: false,
                error: "",
                pageInfo: {
                    hasNextPage: false,
                    hasPreviousPage: false,
                    startCursor: "",
                    endCursor: "",
                },
            };
            this.apiEndpoint = "/api/v1/shopify/product";
            this.isProcessingSelection = false; // Flag to prevent multiple simultaneous selections
        }

        static get observedAttributes() {
            return ["contentfield"];
        }

        get contentField() {
            return this.getAttribute("contentfield");
        }

        connectedCallback() {
            this.render();
            this.loadSelectedFromContentField();
            this.shadowRoot.addEventListener("click", this.handleDocumentClick.bind(this));
        }

        disconnectedCallback() {
            this.shadowRoot.removeEventListener("click", this.handleDocumentClick);
        }

        handleDocumentClick(e) {
            if (e.target.closest(".product-card")) {
                // Handle any click within a product card (including the card itself)
                const productCard = e.target.closest(".product-card");
                this.selectProductFromResult(productCard.dataset.idx);
                e.stopPropagation();
                e.preventDefault();
            }
        }

        async loadSelectedFromContentField() {
            if (this.contentField) {
                const contentFieldElement = document.getElementById(this.contentField);
                console.debug(
                    "Loading from content field:",
                    this.contentField,
                    "Element found:",
                    !!contentFieldElement
                );
                if (contentFieldElement && contentFieldElement.value) {
                    console.debug("Content field value (product ID):", contentFieldElement.value);
                    const productId = contentFieldElement.value.trim();
                    if (productId) {
                        try {
                            await this.loadProductById(productId);
                            console.debug("Loaded product by ID:", productId, this.state.selected);
                        } catch (e) {
                            console.warn("Failed to load product by ID:", productId, e);
                            // Clear invalid product ID
                            contentFieldElement.value = "";
                        }
                    }
                } else {
                    console.log("No content field value found");
                }
            }
        }

        saveSelectedToContentField() {
            if (this.contentField && document.getElementById(this.contentField)) {
                const contentFieldElement = document.getElementById(this.contentField);

                const value = this.state.selected ? this.state.selected.id : "";
                contentFieldElement.value = value;
                console.log("Updated hidden field:", this.contentField, "with product ID:", value);

                // Trigger a change event to notify form systems
                contentFieldElement.dispatchEvent(new Event("change", { bubbles: true }));
            } else {
                console.warn("Content field element not found:", this.contentField);
            }

            this.tryToFillOtherFields();
        }

        tryToFillOtherFields() {
            // try to fill in other fields
            if (!this?.state?.selected) {
                return;
            }

            // title
            this.setNodeValue("title", this.state.selected.title + " - " + this.state.selected.productType);
            this.setNodeValue("productTitle", this.state.selected.title + " - " + this.state.selected.productType);

            // slug/handle
            this.setNodeValue("handle", this.state.selected.handle);
            this.setNodeValue("slug", this.state.selected.handle);
            this.setNodeValue("urlTitle", this.state.selected.handle);
        }

        findNode(nodeId) {
            let ele = dijit.byId(nodeId);
            ele = !ele ? document.getElementById("ele") : ele;
            return ele;
        }

        getNodeValue(node) {
            try {
                return node.getValue();
            } catch (error) {
                try {
                    return node.value;
                } catch (error2) {
                    return "";
                }
            }
        }

        setNodeValue(nodeId, value) {
            let node = this.findNode(nodeId);
            let existingValue = this.getNodeValue(node);
            if (existingValue && existingValue.trim() !== "") {
                return;
            }
            try {
                node.setValue(value);
            } catch (error) {
                try {
                    node.value = value;
                } catch (error2) {}
            }
        }

        async loadProductById(productId) {
            const resp = await fetch(`${this.apiEndpoint}?id=${productId}`);
            if (!resp.ok) {
                throw new Error(resp.statusText);
            }
            const json = await resp.json();

            this.state.selected = json.data.product;
            this.render();
        }

        clearSearch() {
            this.state.search = "";
            this.state.results = [];
            this.state.error = "";
            this.state.searching = false;
            this.render();
            this.state.pageInfo = {};
        }

        async handleSearchInput(e) {
            console.debug("e", e);
            const query = e.target.value;
            this.state.search = query;
            this.state.error = "";
            if (query.trim().length < 3) {
                this.state.results = [];
                this.state.pageInfo = {
                    hasNextPage: false,
                    hasPreviousPage: false,
                    startCursor: "",
                    endCursor: "",
                };
                this.updateResults();
                return;
            }
            await this.performSearch();
        }

        async performSearch(cursor = null, direction = "AFTER") {
            this.state.searching = true;
            this.updateResults();

            try {
                let url = `${this.apiEndpoint}/_search?query=${this.state.search}&limit=20`;
                if (cursor) {
                    url += `&cursor=${encodeURIComponent(cursor)}&before=${direction}`;
                }

                const resp = await fetch(url);
                if (!resp.ok) {
                    throw new Error(resp.statusText);
                }
                const json = await resp.json();
                console.log("json", json.data.products);

                this.state.pageInfo = json.data.products.pageInfo;
                console.debug("pageInfo:", this.state.pageInfo);
                let products = json.data.products.edges.map(function (val) {
                    return val.node;
                });
                console.debug("products", products);
                this.state.results = products;
                if (this.state.results.length === 0) {
                    this.state.error = "No products found.";
                }
                this.state.searching = false;
                this.updateResults();
            } catch (error) {
                this.state.error = "Error searching products.";
                this.state.searching = false;
                this.updateResults();
            }
        }

        async handleNextPage() {
            if (this.state.pageInfo.hasNextPage && this.state.pageInfo.endCursor) {
                await this.performSearch(this.state.pageInfo.endCursor, "AFTER");
            }
        }

        async handlePreviousPage() {
            if (this.state.pageInfo.hasPreviousPage && this.state.pageInfo.startCursor) {
                await this.performSearch(this.state.pageInfo.startCursor, "BEFORE");
            }
        }

        updateResults() {
            const resultsContainer = this.shadowRoot.querySelector(".results");
            const paginationContainer = this.shadowRoot.querySelector(".pagination-container");

            if (resultsContainer) {
                resultsContainer.innerHTML = this.state.searching
                    ? '<div class="spinner"></div>'
                    : this.state.results
                          .map(
                              (prod, i) => `
            <div class="product-card" data-idx="${i}" tabindex="0">
              <img src="${prod.media.edges[0].node.previewImage.url || ""}" alt="" />
              <div class="info">
                <div class="card-title">${prod.title}</div>
                <div class="card-id"><b>Make</b> ${prod.vendor}</div>
                <div class="card-id"><b>ID:</b> ${prod.id}</div>
                <div class="card-body">${prod.description}</div>
              </div>
            </div>
          `
                          )
                          .join("");
            }

            // Update pagination controls
            if (paginationContainer) {
                paginationContainer.innerHTML = this.renderPaginationControls();
            }

            // Update error display
            let errorDiv = this.shadowRoot.querySelector(".search-input").parentElement.querySelector(".error");
            if (this.state.error) {
                if (!errorDiv) {
                    errorDiv = document.createElement("div");
                    errorDiv.className = "error";
                    this.shadowRoot.querySelector(".search-input").parentElement.appendChild(errorDiv);
                }
                errorDiv.textContent = this.state.error;
            } else if (errorDiv) {
                errorDiv.remove();
            }
        }

        selectProductFromResult(idx) {
            // Prevent multiple simultaneous selections
            if (this.isProcessingSelection) {
                //console.log('Selection already in progress, ignoring duplicate call');
                return;
            }

            this.isProcessingSelection = true;

            const prod = this.state.results[idx];
            if (!prod) {
                console.warn("No product found at index:", idx);
                this.isProcessingSelection = false;
                return;
            }

            this.state.selected = prod;
            this.saveSelectedToContentField();
            this.clearSearch(); // This already calls render()

            this.dispatchEvent(
                new CustomEvent("product-selected", {
                    detail: prod,
                    bubbles: true,
                    composed: true,
                })
            );

            // Reset the flag after a short delay to ensure all processing is complete
            setTimeout(() => {
                this.isProcessingSelection = false;
            }, 100);
        }

        clearSelected() {
            this.state.selected = null;
            this.saveSelectedToContentField();
            this.render();
        }

        renderSelected() {
            const prod = this.state.selected;
            return prod
                ? `
        <div class="selected-product">
          <button class="clear-btn" title="Remove selection" onclick="this.getRootNode().host.clearSelected()">✕</button>
          <img src="${
              prod.media && prod.media.edges && prod.media.edges[0] ? prod.media.edges[0].node.previewImage.url : ""
          }" alt="${prod.title}" />
          <div class="selected-info">
            <div class="selected-title"><b>${prod.title}</b></div>
            <div class="selected-vendor">${prod.vendor}</div>
            <div class="selected-price">$${prod.priceRange.minVariantPrice.amount}</div>
            <div class="link-to-product" style="margin-bottom: .5em"><a href="/api/v1/shopify/product/_redirect?id=${
                prod.id
            }" target="_blank">${prod.id}</a> ⤴</div>
            <div class="selected-description">${prod.description ? prod.description.slice(0, 255) + "..." : ""}</div>
          </div>
        </div>
      `
                : `
        <div class="search-container">
          ${this.renderSearchInput()}
          ${this.renderResults()}
        </div>
      `;
        }

        renderSearchInput() {
            return `
        <input type="text" class="search-input" placeholder="Search Shopify products..." value="${this.state.search}" />
        ${this.state.error ? `<div class="error">${this.state.error}</div>` : ""}
      `;
        }

        renderResults() {
            return `
        <div class="results">
          ${
              this.state.searching
                  ? '<div class="spinner"></div>'
                  : this.state.results
                        .map(
                            (prod, i) => `
                <div class="product-card" data-idx="${i}" tabindex="0">
                  <img src="${prod.media.edges[0].node.previewImage.url || ""}" alt="" />
                  <div class="info">
                    <div class="card-title">${prod.title}</div>
                    <div class="card-id"><b>Make</b> ${prod.vendor}</div>
                    <div class="card-id"><b>ID:</b> ${prod.id}</div>
                    <div class="card-body">${prod.description}</div>
                  </div>
                </div>
              `
                        )
                        .join("")
          }

        </div>
        <div class="pagination-container">
          ${this.renderPaginationControls()}
        </div>
      `;
        }

        renderPaginationControls() {
            if (!this.state.results.length || this.state.searching) {
                return "";
            }

            const hasPrevious = this.state.pageInfo.hasPreviousPage;
            const hasNext = this.state.pageInfo.hasNextPage;

            if (!hasPrevious && !hasNext) {
                return "";
            }

            return `
        <div class="pagination-controls">
          <button class="pagination-btn ${hasPrevious ? "" : "disabled"}" 
                  ${hasPrevious ? "" : "disabled"} 
                  onclick="this.getRootNode().host.handlePreviousPage()">
            ← Previous
          </button>
          <button class="pagination-btn ${hasNext ? "" : "disabled"}" 
                  ${hasNext ? "" : "disabled"} 
                  onclick="this.getRootNode().host.handleNextPage()">
            Next →
          </button>
        </div>
      `;
        }

        render() {
            this.shadowRoot.innerHTML = `
      <style>
        .choose-btn,
        .clear-btn { margin-top: 10px; padding: 7px 20px; border-radius: 6px; border: 1px solid #eeeeee; background: #fff; color: #0057d9; cursor: pointer; font-size: 16px; }
        .clear-btn { margin-left: 5px; }
        .clear-btn:hover { background: #eee; }
        .choose-btn:hover { background: #eee; }
        .selected-product { position: relative; display: flex; gap: 15px; align-items: flex-start; border: 1px solid #0057d9; border-radius: 8px; padding: 15px; margin: 10px 0; background: #f8fbff;}
        .selected-product img { width: 150px; height: 150px; object-fit: contain; border-radius: 8px; border: 1px solid #eee; background: white;}
        .selected-info { flex: 1; }
        .selected-title { font-size: 18px; margin-bottom: 5px; color: #333; }
        .selected-vendor { font-size: 14px; color: #666; margin-bottom: 3px; }
        .selected-price { font-size: 16px; font-weight: bold; color: #0057d9; margin-bottom: 8px; }
        .selected-description { font-size: 13px; color: #777; line-height: 1.4; margin-bottom: 12px; }
        .selected-actions { display: flex; gap: 8px; }
        .selected-product .clear-btn { position: absolute; top: 8px; right: 8px; margin: 0; font-size: 16px; padding: 4px 8px; border-radius: 8px; min-width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; }
        .search-container { margin: 10px 0; }
        .search-input { width: 100%;  padding: 10px; margin-bottom: 18px; border-radius: 6px; border: 1px solid #bbb; box-sizing: border-box;}
        .results { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .product-card { display: flex; gap: 16px; align-items: flex-start; border: 1px solid #eee; border-radius: 7px; padding: 11px 12px; background: #fafdff; cursor: pointer; transition: box-shadow 0.2s, background 0.2s;}
        .product-card:hover, .product-card:focus { box-shadow: 0 2px 12px #0088ff22; background: #ecf1fc;}
        .product-card img { width: 150px; height: 150px; object-fit: contain; background: #fafbfc; border-radius: 6px; border: 1px solid #eee;}
        .info { flex: 1; line-height: 1.4; }
        .card-title { font-weight: bold; font-size: 16px; margin-bottom: 5px;}
        .card-body { font-size: 13px; margin-bottom: 3px; color: #555;}
        .card-id { font-size: 12px; color: #777; }
        .error { color: #ca2525; margin: 10px 0; }
        .spinner { width: 36px; height: 36px; border: 4px solid #bbb3; border-top: 4px solid #2299ff; border-radius: 50%; animation: spin 1s linear infinite; margin: 40px auto;}
        @keyframes spin { 100% { transform: rotate(360deg); } }
        .pagination-controls { display: flex; justify-content: center; gap: 12px; margin-top: 15px; padding: 10px 0; border-top: 1px solid #eee; }
        .pagination-btn { padding: 8px 16px; border: 1px solid #0057d9; background: #fff; color: #0057d9; cursor: pointer; border-radius: 6px; font-size: 14px; font-weight: 500; transition: all 0.2s; }
        .pagination-btn:hover:not(.disabled) { background: #0057d9; color: white; }
        .pagination-btn.disabled { background: #f5f5f5; color: #ccc; border-color: #ddd; cursor: not-allowed; opacity: 0.6; }
        </style>
      <div class="product-search-root">
          ${this.renderSelected()}
      </div>
          `;
            // Attach search input event if no product is selected
            if (!this.state.selected) {
                const input = this.shadowRoot.querySelector(".search-input");
                input && input.addEventListener("keyup", this.handleSearchInput.bind(this));
            }
        }
    }

    customElements.define("shopify-product-picker", ShopifyProductPicker);
</script>

]]#

<!-- Place this where you want the picker: -->
<shopify-product-picker contentField="${field.velocityVarName}"></shopify-product-picker>
